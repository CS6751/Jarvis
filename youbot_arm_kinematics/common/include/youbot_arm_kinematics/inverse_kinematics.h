#ifndef INVERSE_KINEMATICS_H
#define INVERSE_KINEMATICS_H

#include <vector>

#include <kdl/frames.hpp>
#include <kdl/jntarray.hpp>

#include <youbot_arm_kinematics/logger.h>


namespace youbot_arm_kinematics
{

/**
 * An analytical IK solver for the youBot arm.
 */
class InverseKinematics
{
    public:
        /**
         * Ctor.
         *
         * @param min_angles The minimum joint limits of the arm. The values are
         * provided as radians [rad].
         *
         * @param max_angles The maximum joint limits of the arm. The values are
         * provided as radians [rad].
         *
         * @param logger The injected logger can be used to receive internal log
         * messages. By default a null object is used which does not do anything
         * with received messages.
         */
        InverseKinematics(
            const std::vector<double> &min_angles,
            const std::vector<double> &max_angles,
            Logger &logger = Logger::null);

        /**
         * Dtor.
         */
        virtual ~InverseKinematics();

        /**
         * Calculate inverse position kinematics, from Cartesian coordinates to
         * joint coordinates.
         *
         * @param q_init A seed value for the inverse kinematics solver. It is
         * usually used in numerical solvers. In analytical solvers it can e.g.
         * contain the current joint configuration, so that the solver returns
         * the closest solution. However, this implementation returns all valid
         * solutions and thus does not use this argument. The values are
         * provided as radians [rad].
         *
         * @param p_in The Cartesian coordinates to solve for. The position
         * vector of the frame is provided as meters [m].
         *
         * @param q_out A list of all found and valid inverse kinematics
         * solutions. The values are provided as radians [rad].
         *
         * @return A value greater than zero if a solution was found or a value
         * less than zero if no solution was found.
         */
        int CartToJnt(const KDL::JntArray &q_init,
            const KDL::Frame &p_in,
            std::vector<KDL::JntArray> &q_out);


    private:
        /**
         * Tell if a solution is inside of the joint limits.
         *
         * @param solution The solution that has been generated by the IK
         * solver.
         *
         * @return True if the solution is valid else false.
         */
        bool isSolutionValid(const KDL::JntArray &solution) const;

        /**
         * The IK solver. It implements a best-effort approach to find a
         * solution: The youBot arm with its five degrees of freedom is
         * deficient and therefore can only reach a limited set of arbitrary
         * six-dimensional Cartesian poses (within the workspace). This IK
         * solver finds solutions for arbitrary poses (within the workspace)
         * anyway. However, most solutions contain a certain error. The solution
         * is based on the inverse position kinematics of the Yasukawa Motoman
         * L-3 [1].
         *
         * [1] Craig, John J. Horton, M. J. (Ed.).
         *     Introduction to Robotics - Mechanics and Control.
         *     Prentice Hall, 2005.
         *
         * @param frame The Cartesian target frame for which the inverse
         * kinematics solves.
         *
         * @param offset_joint_1 Chooses if the first joint points towards or
         * away from the target.
         *
         * @param offset_joint_3 Chooses between elbow-up and elbow-down
         * solution
         *
         * @return If there is a solution a JntArray with five entries is
         * returned, else the JntArray is empty.
         */
        KDL::JntArray ik(const KDL::Frame &frame, bool offset_joint_1 = false,
                bool offset_joint_3 = false);

        KDL::Frame projectGoalOrientationIntoArmSubspace(
                const KDL::Frame &goal) const;


    private:
        /**
         * Minimum joint limits.
         */
        std::vector<double> min_angles_;

        /**
         * Maximum joint limits.
         */
        std::vector<double> max_angles_;

        /**
         * The injected logger to send messages to the application which is
         * using this library.
         */
        Logger &logger_;

        /**
         * Threshold when a number is near to +1 or -1. This is required to
         * prevent invalid arguments to acos.
         */
        static const double ALMOST_PLUS_ONE;
        static const double ALMOST_MINUS_ONE;
};

}

#endif
